# K-POP 아티스트별 인기도 트렌드 분석 및 예측 시스템

## 1. 프로젝트 개요

### 1.1 목적
YouTube Data API를 통해 수집한 K-POP 관련 데이터를 기반으로 **아티스트/그룹별 인기도를 분석하고, 미래 트렌드를 예측**하는 빅데이터 시스템 구축

### 1.2 핵심 질문
- 어떤 K-POP 아티스트가 가장 인기 있는가?
- 각 아티스트의 인기도 트렌드는 상승/하락/유지 중인가?
- 다음 주/다음 달 인기 아티스트는 누구인가?
- 어떤 신인 그룹이 차세대 스타가 될 가능성이 높은가?

### 1.3 활용 시나리오
- **기획사**: 투자 우선순위 결정, 신인 발굴
- **마케터**: 협업 파트너 선정, 광고 타겟팅
- **팬**: 차세대 스타 조기 발견
- **분석가**: K-POP 시장 트렌드 모니터링

---

## 2. 데이터 파이프라인 설계

### 2.1 전체 아키텍처

> ✅ 구현 현황 (2025-10)
> - `video_social_rtp/core/artists.py`: 제목/채널 기반 아티스트 정규화 로직
> - `bronze` 단계: 아티스트 필드를 포함한 Delta 파티션(`ingest_date`, `artist`)
> - `silver` 단계: 아티스트 × 시간 창 슬라이딩 집계(참여도, 고유 비디오/작성자)
> - `gold` 단계: 아티스트 티어 피처 및 CDF 기반 Tier(1~4) 산출, `gold_tiers.json` 아티팩트
> - `train` 단계: 다중 클래스(LogReg, RandomForest) 평가 후 Pareto 최적 모델 선택


```
YouTube API v3 (K-POP 검색)
    ↓
[Landing Layer] - 원본 데이터 저장 (NDJSON)
    ├─ video_id, title, channel_id, timestamp
    └─ Reservoir Sampling (대표 샘플)
    ↓
[Bronze Layer] - 중복 제거 (Bloom Filter + Delta Lake)
    ├─ 아티스트명 추출 (제목 파싱)
    └─ 파티션: ingest_date, artist
    ↓
[Silver Layer] - 실시간 집계 (Structured Streaming)
    ├─ Sliding Window (1시간/5분)
    ├─ Watermark (10분 지연 허용)
    └─ 아티스트별 시간대별 참여도 집계
    ↓
[Gold Layer] - 피처 엔지니어링 & 라벨링
    ├─ 아티스트별 집계 피처
    │   - total_videos: 총 비디오 수
    │   - total_engagement: 총 참여도
    │   - avg_engagement: 평균 참여도
    │   - unique_viewers_est: HyperLogLog 고유 시청자 추정
    │   - growth_rate: 7일 대비 성장률
    ├─ 트렌드 피처
    │   - trend_direction: 상승/하락/유지
    │   - momentum: 최근 7일 가속도
    ├─ 라벨링 (CDF 기반)
    │   - tier_1: 초대형 (상위 5%)
    │   - tier_2: 대형 (상위 5-15%)
    │   - tier_3: 중형 (상위 15-40%)
    │   - tier_4: 소형 (나머지 60%)
    └─ Delta Lake + CSV 저장
    ↓
[Train Layer] - 다중 모델 학습
    ├─ 입력: total_engagement, avg_engagement, growth_rate, unique_viewers_est
    ├─ 출력: tier (1~4)
    ├─ 모델: Logistic Regression, Random Forest, GBT
    └─ Pareto Front 최적 모델 선택
    ↓
[Predict & Serve] - 실시간 예측 및 시각화
    ├─ Streamlit UI
    ├─ 아티스트별 인기도 대시보드
    ├─ 트렌드 차트 (시계열)
    └─ 예측 결과 및 추천
```

---

## 3. 데이터 수집 전략

### 3.1 검색어 설계

#### 3.1.1 아티스트/그룹명 (메인 검색어)
```python
ARTIST_QUERIES = [
    # 4세대 (현재 대세)
    "NewJeans", "뉴진스",
    "aespa", "에스파",
    "LE SSERAFIM", "르세라핌",
    "IVE", "아이브",
    "ITZY", "있지",
    "NMIXX", "엔믹스",
    "Kep1er", "케플러",
    "Stray Kids", "스트레이 키즈",
    "ATEEZ", "에이티즈",
    "ENHYPEN", "엔하이픈",
    
    # 3세대 (중견)
    "BLACKPINK", "블랙핑크",
    "TWICE", "트와이스",
    "Red Velvet", "레드벨벳",
    "SEVENTEEN", "세븐틴",
    "NCT", "엔시티",
    "GOT7", "갓세븐",
    
    # 레전드 (2세대)
    "BTS", "방탄소년단",
    "BIGBANG", "빅뱅",
    "EXO", "엑소",
    "Girls Generation", "소녀시대",
    "2NE1", "투애니원",
    "SHINee", "샤이니",
    
    # 신인 (5세대)
    "BABYMONSTER", "베이비몬스터",
    "RIIZE", "라이즈",
    "ZEROBASEONE", "제로베이스원",
]
```

#### 3.1.2 컨텍스트 검색어 (보조)
```python
CONTEXT_QUERIES = [
    "{artist} MV",
    "{artist} 무대",
    "{artist} 신곡",
    "{artist} 컴백",
    "{artist} 라이브",
]
```

### 3.2 수집 파라미터
```bash
PIPELINE_MAX_ITEMS=50        # 각 검색당 50개 비디오
PIPELINE_QUERIES_PER_DAY=20  # 하루 20개 검색어
PIPELINE_RUNS_PER_DAY=2      # 하루 2회 실행
```

**일일 수집량**: 20 queries × 50 videos × 2 runs = **2,000개 비디오/일**

---

## 4. 피처 엔지니어링

### 4.1 아티스트명 추출

#### 4.1.1 제목 파싱
```python
def extract_artist(title: str) -> str:
    """비디오 제목에서 아티스트명 추출"""
    
    ARTIST_PATTERNS = {
        "뉴진스": ["NewJeans", "뉴진스", "newjeans"],
        "에스파": ["aespa", "에스파", "æspa"],
        "블랙핑크": ["BLACKPINK", "블랙핑크", "blackpink"],
        "방탄소년단": ["BTS", "방탄소년단", "bts", "防弾少年団"],
        # ... 더 많은 패턴
    }
    
    title_lower = title.lower()
    for canonical, patterns in ARTIST_PATTERNS.items():
        for pattern in patterns:
            if pattern.lower() in title_lower:
                return canonical
    
    return "기타"  # Unknown artist
```

#### 4.1.2 채널 기반 매핑 (보조)
```python
OFFICIAL_CHANNELS = {
    "UCOmHUn--16B90oW2L6FRR3A": "블랙핑크",
    "UCx9hXYOCvUYwrprEqe4ZQHA": "트레저",
    # ... 공식 채널 매핑
}
```

### 4.2 Gold 피처 정의

#### 4.2.1 기본 집계 피처
```python
features = {
    "artist": str,           # 아티스트명
    "total_videos": int,     # 총 비디오 수
    "total_engagement": float,     # 총 참여도 (24시간)
    "avg_engagement": float,       # 평균 참여도
    "max_engagement": float,       # 최대 참여도
    "unique_viewers_est": float,   # HLL 고유 시청자 추정
}
```

#### 4.2.2 트렌드 피처 (시계열 분석)
```python
trend_features = {
    "growth_rate_7d": float,       # 7일 대비 성장률 (%)
    "growth_rate_30d": float,      # 30일 대비 성장률 (%)
    "momentum": float,             # 가속도 (2차 미분)
    "trend_direction": str,        # "상승", "하락", "유지"
    "volatility": float,           # 변동성 (표준편차)
}
```

#### 4.2.3 상대적 지표
```python
relative_features = {
    "rank": int,                   # 전체 순위
    "percentile": float,           # 상위 몇 %
    "market_share": float,         # 전체 대비 비중 (%)
}
```

### 4.3 라벨링 (Tier 분류)

#### 4.3.1 CDF 기반 Tier 할당
```python
def assign_tier(engagement: float, percentile: float) -> int:
    """
    CDF 기반 티어 할당
    
    Tier 1 (초대형): 상위 5% (BTS, BLACKPINK 급)
    Tier 2 (대형):   상위 5-15% (NewJeans, aespa 급)
    Tier 3 (중형):   상위 15-40% (신인 상위권)
    Tier 4 (소형):   나머지 60% (일반 그룹)
    """
    if percentile >= 0.95:
        return 1  # 초대형
    elif percentile >= 0.85:
        return 2  # 대형
    elif percentile >= 0.60:
        return 3  # 중형
    else:
        return 4  # 소형
```

#### 4.3.2 Cutoff 계산
```python
# 각 Tier의 경계값 계산
cutoffs = {
    "tier_1": np.percentile(engagements, 95),  # 상위 5%
    "tier_2": np.percentile(engagements, 85),  # 상위 15%
    "tier_3": np.percentile(engagements, 60),  # 상위 40%
}
```

---

## 5. 모델 학습 및 예측

### 5.1 학습 데이터 구성

#### 5.1.1 입력 피처 (X)
```python
feature_columns = [
    "total_engagement",      # 총 참여도
    "avg_engagement",        # 평균 참여도
    "unique_viewers_est",    # 고유 시청자
    "growth_rate_7d",        # 7일 성장률
    "growth_rate_30d",       # 30일 성장률
    "momentum",              # 가속도
    "total_videos",          # 비디오 수
]
```

#### 5.1.2 타겟 레이블 (y)
```python
target = "tier"  # 1, 2, 3, 4 (다중 클래스 분류)
```

### 5.2 모델 학습

#### 5.2.1 사용 모델
```python
from pyspark.ml.classification import (
    LogisticRegression,      # 빠름, 해석 가능
    RandomForestClassifier,  # 중간, 앙상블
    GBTClassifier           # 느림, 고성능
)

models = {
    "lr": LogisticRegression(
        featuresCol="features",
        labelCol="tier_idx",
        maxIter=100
    ),
    "rf": RandomForestClassifier(
        featuresCol="features",
        labelCol="tier_idx",
        numTrees=200,
        maxDepth=10
    ),
    "gbt": GBTClassifier(
        featuresCol="features",
        labelCol="tier_idx",
        maxIter=80,
        maxDepth=6
    )
}
```

#### 5.2.2 평가 지표
```python
metrics = {
    "accuracy": MulticlassClassificationEvaluator(metricName="accuracy"),
    "f1": MulticlassClassificationEvaluator(metricName="f1"),
    "latency_ms": inference_time,  # 추론 속도
    "feature_count": len(feature_columns),  # 복잡도
}
```

#### 5.2.3 Pareto Front 선택
```python
# 다목적 최적화
objectives = {
    "f1": "maximize",           # F1 점수 최대화
    "latency_ms": "minimize",   # 지연 시간 최소화
    "feature_count": "minimize" # 복잡도 최소화
}

# Pareto 전선에서 최적 모델 자동 선택
best_model = select_pareto_optimal(results, objectives)
```

### 5.3 예측 시스템

#### 5.3.1 예측 입력
```python
# 신규 아티스트 데이터
new_artist = {
    "artist": "RIIZE",
    "total_engagement": 1250.0,
    "avg_engagement": 62.5,
    "unique_viewers_est": 980.0,
    "growth_rate_7d": 45.2,  # 7일 대비 45% 성장
    "growth_rate_30d": 120.5,  # 30일 대비 120% 성장
    "momentum": 15.3,
    "total_videos": 20
}
```

#### 5.3.2 예측 출력
```python
prediction = {
    "artist": "RIIZE",
    "predicted_tier": 2,  # 대형 (상위 15%)
    "probability": {
        "tier_1": 0.15,  # 15% 초대형 가능성
        "tier_2": 0.65,  # 65% 대형 가능성
        "tier_3": 0.18,  # 18% 중형 가능성
        "tier_4": 0.02   # 2% 소형 가능성
    },
    "trend": "급상승",
    "recommendation": "주목할 만한 신인 그룹. 투자 가치 높음"
}
```

---

## 6. 라벨링 전략

### 6.1 Tier 분류 기준

#### 6.1.1 정량적 기준 (CDF 기반)
```python
tier_classification = {
    "Tier 1 (초대형)": {
        "percentile": "상위 5%",
        "total_engagement": "> 10,000",
        "avg_engagement": "> 500",
        "growth_rate_7d": "> 20%",
        "예시": ["BTS", "BLACKPINK", "TWICE"]
    },
    "Tier 2 (대형)": {
        "percentile": "상위 5-15%",
        "total_engagement": "5,000 - 10,000",
        "avg_engagement": "200 - 500",
        "growth_rate_7d": "10 - 20%",
        "예시": ["NewJeans", "aespa", "SEVENTEEN"]
    },
    "Tier 3 (중형)": {
        "percentile": "상위 15-40%",
        "total_engagement": "1,000 - 5,000",
        "avg_engagement": "50 - 200",
        "growth_rate_7d": "0 - 10%",
        "예시": ["NMIXX", "Kep1er", "ENHYPEN"]
    },
    "Tier 4 (소형)": {
        "percentile": "나머지 60%",
        "total_engagement": "< 1,000",
        "avg_engagement": "< 50",
        "growth_rate_7d": "< 0%",
        "예시": ["신인 그룹", "데뷔 준비 중"]
    }
}
```

#### 6.1.2 동적 Cutoff 계산
```python
import numpy as np

def calculate_tier_cutoffs(engagements: list) -> dict:
    """CDF 기반 동적 티어 경계값 계산"""
    
    sorted_vals = sorted(engagements)
    
    return {
        "tier_1_cutoff": np.percentile(sorted_vals, 95),   # 상위 5%
        "tier_2_cutoff": np.percentile(sorted_vals, 85),   # 상위 15%
        "tier_3_cutoff": np.percentile(sorted_vals, 60),   # 상위 40%
    }
```

### 6.2 트렌드 방향 라벨링

```python
def classify_trend(growth_rate_7d: float, momentum: float) -> str:
    """
    트렌드 방향 분류
    
    급상승: 성장률 > 30% AND 가속도 > 10
    상승: 성장률 > 10%
    유지: -10% < 성장률 < 10%
    하락: 성장률 < -10%
    급하락: 성장률 < -30% AND 가속도 < -10
    """
    
    if growth_rate_7d > 30 and momentum > 10:
        return "급상승"
    elif growth_rate_7d > 10:
        return "상승"
    elif -10 < growth_rate_7d < 10:
        return "유지"
    elif growth_rate_7d < -30 and momentum < -10:
        return "급하락"
    else:
        return "하락"
```

---

## 7. 구현 코드 수정 사항

### 7.1 Bronze Layer 수정

**파일**: `video_social_rtp/bronze/batch.py`

```python
def extract_artist_from_title(title: str) -> str:
    """제목에서 아티스트명 추출"""
    
    # 아티스트 패턴 매칭
    for canonical, patterns in ARTIST_PATTERNS.items():
        for pattern in patterns:
            if pattern.lower() in title.lower():
                return canonical
    
    return "기타"

# Bronze 저장 시 artist 컬럼 추가
df = df.withColumn("artist", extract_artist_udf(col("text")))
```

### 7.2 Silver Layer 수정

**파일**: `video_social_rtp/silver/stream.py`

```python
# 아티스트별 시간대별 집계
agg_df = (
    windowed
    .groupBy("window", "artist")
    .agg(
        count("video_id").alias("video_count"),
        countDistinct("video_id").alias("unique_videos"),
        sum("engagement").alias("total_engagement")
    )
)
```

### 7.3 Gold Layer 수정

**파일**: `video_social_rtp/features/gold.py`

```python
def create_artist_features(silver_df):
    """아티스트별 피처 생성"""
    
    # 기본 집계
    artist_agg = (
        silver_df
        .groupBy("artist")
        .agg(
            sum("video_count").alias("total_videos"),
            sum("total_engagement").alias("total_engagement"),
            avg("total_engagement").alias("avg_engagement"),
            approx_count_distinct("unique_videos").alias("unique_viewers_est")
        )
    )
    
    # 성장률 계산 (7일 전 데이터와 비교)
    current = artist_agg
    previous_7d = get_data_7_days_ago()
    
    growth = (
        current
        .join(previous_7d, "artist", "left")
        .withColumn(
            "growth_rate_7d",
            ((col("total_engagement") - col("prev_engagement")) / col("prev_engagement")) * 100
        )
    )
    
    # 티어 할당
    cutoffs = calculate_tier_cutoffs(engagements)
    
    labeled = (
        growth
        .withColumn("tier", 
            when(col("total_engagement") >= cutoffs["tier_1"], 1)
            .when(col("total_engagement") >= cutoffs["tier_2"], 2)
            .when(col("total_engagement") >= cutoffs["tier_3"], 3)
            .otherwise(4)
        )
    )
    
    return labeled
```

### 7.4 Train Layer 수정

**파일**: `video_social_rtp/train/pareto.py`

```python
# 다중 클래스 분류로 변경
from pyspark.ml.classification import LogisticRegression
from pyspark.ml.evaluation import MulticlassClassificationEvaluator

# StringIndexer로 tier를 숫자 인덱스로 변환
indexer = StringIndexer(inputCol="tier", outputCol="tier_idx")

# 다중 클래스 평가
evaluator = MulticlassClassificationEvaluator(
    labelCol="tier_idx",
    predictionCol="prediction",
    metricName="f1"
)

# 4개 클래스 (tier 1~4) 학습
for name, clf in models.items():
    pipeline = Pipeline(stages=[indexer, assembler, clf])
    model = pipeline.fit(train_df)
    predictions = model.transform(test_df)
    f1_score = evaluator.evaluate(predictions)
    # ...
```

---

## 8. Streamlit UI 설계

### 8.1 대시보드 레이아웃

```python
# Streamlit UI 구조
st.title("K-POP 아티스트 인기도 분석 대시보드")

# 사이드바
with st.sidebar:
    st.header("검색 옵션")
    artist_name = st.text_input("아티스트명", "NewJeans")
    tier_filter = st.multiselect("Tier 필터", [1, 2, 3, 4], default=[1, 2])
    top_k = st.slider("Top-K", 5, 50, 20)

# 메인 컨텐츠
col1, col2, col3 = st.columns(3)

with col1:
    st.metric("전체 아티스트 수", total_artists)
    
with col2:
    st.metric("분석 비디오 수", total_videos)
    
with col3:
    st.metric("데이터 기간", f"{days}일")

# 아티스트 순위 테이블
st.subheader("아티스트 인기도 순위")
st.dataframe(artist_ranking)

# 트렌드 차트
st.subheader("인기도 트렌드")
st.line_chart(trend_data)

# 예측 결과
if artist_name:
    st.subheader(f"{artist_name} 예측 결과")
    st.write(f"예측 Tier: {predicted_tier}")
    st.write(f"트렌드: {trend_direction}")
    st.progress(growth_rate / 100)
```

### 8.2 시각화 컴포넌트

#### 8.2.1 인기도 분포 (CDF/PDF)
```python
import altair as alt

# CDF 차트
cdf_chart = alt.Chart(df).mark_line().encode(
    x=alt.X("total_engagement:Q", title="Total Engagement"),
    y=alt.Y("cumulative:Q", title="Cumulative %"),
    tooltip=["total_engagement", "cumulative"]
).properties(
    title="아티스트 인기도 누적 분포 (CDF)",
    width=600,
    height=400
)

# Tier 경계선 표시
tier_lines = alt.Chart(pd.DataFrame([
    {"cutoff": cutoffs["tier_1"], "tier": "Tier 1"},
    {"cutoff": cutoffs["tier_2"], "tier": "Tier 2"},
    {"cutoff": cutoffs["tier_3"], "tier": "Tier 3"}
])).mark_rule(strokeDash=[5, 5]).encode(
    x="cutoff:Q",
    color="tier:N"
)

st.altair_chart(cdf_chart + tier_lines)
```

#### 8.2.2 시계열 트렌드
```python
# 시간에 따른 인기도 변화
trend_chart = alt.Chart(trend_df).mark_line(point=True).encode(
    x=alt.X("date:T", title="날짜"),
    y=alt.Y("total_engagement:Q", title="참여도"),
    color="artist:N",
    tooltip=["date", "artist", "total_engagement", "tier"]
).properties(
    title="아티스트별 인기도 트렌드",
    width=800,
    height=500
)

st.altair_chart(trend_chart)
```

#### 8.2.3 티어 분포 (파이 차트)
```python
tier_dist = df["tier"].value_counts()

fig = px.pie(
    values=tier_dist.values,
    names=["Tier 1 (초대형)", "Tier 2 (대형)", "Tier 3 (중형)", "Tier 4 (소형)"],
    title="아티스트 티어 분포"
)

st.plotly_chart(fig)
```

---

## 9. 실행 예시

### 9.1 데이터 수집
```bash
# 아티스트 검색어로 데이터 수집
python -m video_social_rtp.cli fetch \
    --query "NewJeans" \
    --max-items 50 \
    --relevance-language ko \
    --region-code KR
```

### 9.2 파이프라인 실행
```bash
# Bronze: 아티스트명 추출 및 저장
python -m video_social_rtp.cli bronze

# Silver: 아티스트별 시간대별 집계
python -m video_social_rtp.cli silver --once

# Gold: 아티스트별 피처 생성 및 티어 라벨링
python -m video_social_rtp.cli gold --tier-cutoffs "0.95,0.85,0.60"

# Train: 티어 분류 모델 학습
python -m video_social_rtp.cli train --target tier

# UI: 대시보드 실행
python -m video_social_rtp.cli ui
```

### 9.3 예측 결과 예시

#### 9.3.1 아티스트 순위 (30일 데이터 기준)

| 순위 | 아티스트 | Tier | Total Engagement | Growth Rate (7d) | 트렌드 |
|------|----------|------|------------------|------------------|--------|
| 1 | NewJeans | 1 | 15,420 | +35.2% | 급상승 🔥 |
| 2 | aespa | 1 | 14,850 | +18.5% | 상승 ⬆️ |
| 3 | IVE | 2 | 8,920 | +12.3% | 상승 ⬆️ |
| 4 | LE SSERAFIM | 2 | 7,650 | +8.1% | 유지 → |
| 5 | ITZY | 2 | 6,340 | -5.2% | 하락 ⬇️ |
| 6 | NMIXX | 3 | 3,120 | +45.8% | 급상승 🔥 |
| 7 | BABYMONSTER | 3 | 2,890 | +120.5% | 급상승 🔥 |
| 8 | RIIZE | 3 | 1,250 | +85.3% | 급상승 🔥 |

#### 9.3.2 예측 결과

**예측 질문**: "RIIZE는 다음 달 어느 Tier가 될까?"

**입력 데이터**:
- 현재 Tier: 3 (중형)
- Total Engagement: 1,250
- Growth Rate (7d): +85.3%
- Growth Rate (30d): +220.5%
- Momentum: 25.8 (매우 높음)

**예측 결과**:
- **예측 Tier**: 2 (대형) 
- **확률**: 72%
- **트렌드**: 급상승 🔥
- **예상 도달 시기**: 2주 이내
- **추천**: 적극적 투자 및 마케팅 권장

---

## 10. 데이터 흐름 검증 체크리스트

### 10.1 수집 단계
- [ ] YouTube API로 아티스트 검색어 수집
- [ ] 50+ 아티스트명으로 다양한 데이터 확보
- [ ] Landing 파일에 title, video_id, channel_id 포함

### 10.2 처리 단계
- [ ] Bronze: 제목에서 아티스트명 추출
- [ ] Silver: 아티스트별 시간대별 집계
- [ ] Gold: 아티스트별 피처 계산 (7일/30일 트렌드 포함)

### 10.3 라벨링 단계
- [ ] CDF 기반 Tier 1~4 cutoff 계산
- [ ] 각 아티스트에 Tier 할당
- [ ] 최소 4개 Tier 모두 데이터 존재 확인
- [ ] CSV 파일 생성 확인

### 10.4 학습 단계
- [ ] 4개 클래스 데이터 확인
- [ ] 모델 학습 성공
- [ ] Pareto Front 선택 완료
- [ ] F1 score > 0.5 달성

### 10.5 예측 단계
- [ ] 신규 아티스트 데이터 입력
- [ ] Tier 예측 결과 생성
- [ ] 확률 분포 표시
- [ ] 트렌드 방향 분류

---

## 11. 30일 데이터 축적 시 예상 결과

### 11.1 데이터 규모
- **총 비디오**: 60,000개 (2,000개/일 × 30일)
- **고유 아티스트**: 100-150명
- **Tier별 분포**:
  - Tier 1: 5-8명 (상위 5%)
  - Tier 2: 10-15명 (상위 15%)
  - Tier 3: 25-40명 (상위 40%)
  - Tier 4: 60-90명 (나머지)

### 11.2 모델 성능 예상
- **Accuracy**: 0.70-0.85
- **F1 Score**: 0.65-0.80
- **Pareto 모델**: Random Forest (균형적 성능)

### 11.3 인사이트 예시
- "NewJeans는 30일간 35% 성장, Tier 1 유지"
- "BABYMONSTER는 신인이지만 급성장 중, Tier 3 → Tier 2 상승 예측"
- "ITZY는 하락 트렌드, 컴백 필요"

---

## 12. 구현 순서

### Phase 1: 데이터 수집 (1-3일)
1. 아티스트 검색어 목록 확장
2. 수집 자동화 검증
3. Landing 데이터 확인

### Phase 2: 아티스트 추출 (4-7일)
1. 제목 파싱 로직 구현
2. 아티스트 패턴 매칭
3. Bronze 레이어 수정

### Phase 3: 집계 및 피처 (8-14일)
1. Silver 아티스트별 집계
2. Gold 피처 엔지니어링
3. 트렌드 계산 (7일/30일)

### Phase 4: 라벨링 (15-21일)
1. CDF 기반 Tier cutoff 계산
2. Tier 1~4 라벨 할당
3. 데이터 분포 검증

### Phase 5: 학습 및 예측 (22-28일)
1. 다중 클래스 모델 학습
2. Pareto Front 선택
3. 예측 시스템 구축

### Phase 6: UI 및 검증 (29-30일)
1. Streamlit 대시보드 구현
2. 시각화 완성
3. 전체 파이프라인 검증

---

## 13. 장점 및 차별점

### 13.1 기존 "바이럴 예측" 대비 개선점

| 구분 | 바이럴 예측 | 아티스트 인기도 분석 |
|------|-------------|---------------------|
| **목적 명확성** | "바이럴"의 정의 모호 | 아티스트 순위 명확 |
| **분류** | 2개 클래스 (0/1) | 4개 Tier (계층적) |
| **실용성** | 제한적 | 투자/마케팅 직접 활용 |
| **검증** | 어려움 | 실제 차트와 비교 가능 |
| **트렌드** | 정적 | 시간 흐름 추적 |

### 13.2 빅데이터 특성 강조
- ✅ **대규모 데이터**: 100+ 아티스트 × 30일
- ✅ **실시간 처리**: Streaming 집계
- ✅ **시계열 분석**: 트렌드 추적
- ✅ **다목적 최적화**: Pareto Front

### 13.3 학술적 가치
- ✅ **Reservoir Sampling**: 대표성 확보
- ✅ **Bloom Filter**: 중복 제거
- ✅ **HyperLogLog**: 근사 계산
- ✅ **CDF/PDF**: 동적 분류
- ✅ **Pareto Front**: 다목적 최적화

---
